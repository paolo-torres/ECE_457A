#include <algorithm>
#include <iostream>
#include <utility>
#include <vector>

using namespace std;

const vector<vector<const char>> maze {
    {'1', '1', '1', '1', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '0', '1', '1', '1', '1', '1', '1'},
    {'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
    {'0', '0', '0', '0', '0', '1', '1', '1', '0', '1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '1'},
    {'1', '1', 'B', '0', '0', '0', '1', '1', '0', '1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '1'},
    {'1', '1', '1', '0', '0', '0', '1', '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '0', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', 'A', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '0', '0', '0', '1', '1', '1', '0', '0', '0', '0', '0', '0', '0', '1', '1', '*', '1'},
    {'0', '0', '0', '0', '0', '0', '0', '1', '0', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '*', '1'},
    {'1', '1', '*', '*', '*', '*', '*', '*', '*', '*', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0'},
    {'1', '1', '*', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '0'},
    {'1', '1', '*', '1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '1', '1', '0', '0', '1', '1', '1', '1', '1', '0', '0', '0'},
    {'1', '1', '*', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0', '1', '1', '1', '1', '0', '0', '0', '0'},
    {'1', '1', '*', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '0', '0', '1', '0', '1', '1', '0', '1', '1', '0'},
    {'1', '1', 'S', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '0', '1', '0', '1', '1', '0', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '0', '1', '0', '1', '1', '0', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '1', '1'},
    {'1', '1', '0', '0', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '0', '1', '1', '1'},
    {'1', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '0', '0', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '1'},
    {'1', '1', '0', '1', '1', '1', '0', '0', '1', '1', '0', '0', '0', '1', '1', '1', '1', '1', '0', '0', '0', '0', '0', '0', '1'},
    {'0', '0', '0', '1', '1', '1', '0', '0', '1', '1', '0', '0', '0', '1', '1', '1', '1', '1', '0', '0', '0', '0', '1', '1', '1'},
    {'0', '0', '0', '1', '1', '1', '0', '0', '1', '1', '0', '0', '0', '1', '1', '1', '1', '1', '0', '0', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '0', '0', '1', '1', '0', '0', '0', '1', '1', '1', '1', '1', '0', '0', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '0', '0', '1', '1', '1', '1', '1', '0', '0', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '0', '1', '1', '1', '1', '1'},
    {'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'}
};

bool dfs(vector<vector<bool>> visited, vector<pair<int, int>> &path, int &nodes, int i, int j, int endX, int endY) {
    ++nodes;
    if (!visited[i][j]) {
        visited[i][j] = true;
        path.push_back(make_pair(i, j));
        if (i == endX && j == endY) {
            return true;
        }
        if (j > 0 && maze[i][j-1] != '0') {
            if (dfs(visited, path, nodes, i, j - 1, endX, endY)) {
                return true;
            }
        }
        if (i > 0 && maze[i-1][j] != '0') {
            if (dfs(visited, path, nodes, i - 1, j, endX, endY)) {
                return true;
            }
        }
        if (j < maze[0].size() - 1 && maze[i][j+1] != '0') {
            if (dfs(visited, path, nodes, i, j + 1, endX, endY)) {
                return true;
            }
        }
        if (i < maze.size() && maze[i+1][j] != '0') {
            if (dfs(visited, path, nodes, i + 1, j, endX, endY)) {
                return true;
            }
        }
        path.pop_back();
        visited[i][j] = false;
    }
    return false;
}

void applyDFS(int i, int j, int endX, int endY) {
    vector<vector<bool>> visited(maze.size(), vector<bool>(maze[0].size(), false));

    vector<pair<int, int>> path;
    int nodes = 0;

    if (dfs(visited, path, nodes, i, j, endX, endY)) {
        cout << "Path: ";
        for (int i = 0; i < path.size(); ++i) {
            cout << '\t' << "(" << path[i].first << "," << path[i].second << ")" << endl;
        }
        cout << "Cost: \t" << path.size() << endl;
        cout << "Nodes: \t" << nodes << endl << endl;
    }

    for (auto &v: visited) {
        fill(v.begin(), v.end(), false);
    }

    path.clear();
    nodes = 0;
}

int main() {
    cout << "Depth-First Search" << endl << endl;

    applyDFS(13, 2, 5, 23);
    applyDFS(13, 2, 3, 2);
    applyDFS(24, 0, 0, 24);

    return 0;
}
